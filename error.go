package xtrace

import (
	"fmt"
	"strings"
	"unicode"

	"golang.org/x/xerrors"
)

// formatSprinter's pointer type implements the xerrors.Printer interface, but wraps fmt.Sprintf, and will store the
// last errors' error type internally
type formatSprinter struct {
	// The outputs generated by the print methods
	messages []string
	// Whether or not to get detailed output
	detail    bool
	separator string
}

// Print takes the output of fmt.Sprint and stores it in output
func (sprinter *formatSprinter) Print(args ...interface{}) {
	message := fmt.Sprint(args...)
	sprinter.insertMessage(message)
}

// Print takes the output of fmt.Sprintf and stores it in output
func (sprinter *formatSprinter) Printf(format string, args ...interface{}) {
	message := fmt.Sprintf(format, args...)
	sprinter.insertMessage(message)
}

// Detail will give detailed output as requested by the creater of this type
func (sprinter *formatSprinter) Detail() bool {
	return sprinter.detail
}

// insertMessage inserts the given message with a normalized format
func (sprinter *formatSprinter) insertMessage(message string) {
	// TODO: maybe break this out into an interface type to allow for format customization?
	formattedMessage := strings.TrimRightFunc(message, unicode.IsSpace)
	// All messages except the first must begin with a tab
	if len(sprinter.messages) > 0 {
		formattedMessage = fmt.Sprintf("\t%s", formattedMessage)
	}

	sprinter.messages = append(sprinter.messages, formattedMessage)

	// All messages except the first must end with a newline; reach back into the original array to insert one
	if len(sprinter.messages) == 1 {
		return
	}

	lastMessage := sprinter.messages[len(sprinter.messages)-2]
	if lastMessage[len(lastMessage)-1] != '\n' {
		lastMessage = fmt.Sprintf("%s\n", lastMessage)
		sprinter.messages[len(sprinter.messages)-2] = lastMessage
	}
}

// output generates the output of a sprinter as a string. If Detail is disabled, only the first message is returned.
func (sprinter *formatSprinter) output() string {
	// Just return the message without a newline if we have one message
	if len(sprinter.messages) == 1 {
		return sprinter.messages[0]
	}

	return strings.Join(sprinter.messages, "")
}

// generateErrorString will produce the result of the given xerrors.Formatter with/without detail, as requested.
// If the given error does not implement xerrors.Formatter, will return err.Error() instead
func generateErrorString(err error, detail bool) (message string, next error) {
	formatter, isFormatter := err.(xerrors.Formatter)
	if !isFormatter {
		return err.Error(), xerrors.Unwrap(err)
	}

	sprinter := &formatSprinter{detail: detail}
	next = formatter.FormatError(sprinter)
	message = sprinter.output()

	return
}
